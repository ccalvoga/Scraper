document.addEventListener('DOMContentLoaded', () => {
    const editors = {
        'fuentes.csv': document.getElementById('fuentes-editor'),
        'exclusiones.txt': document.getElementById('exclusiones-editor'),
        'terminos_interes.txt': document.getElementById('terminos-editor'),
    };

    const logOutput = document.getElementById('log-output');
    const procesadosOutput = document.getElementById('procesados-output');
    const startScrapeBtn = document.getElementById('start-scrape');
    const cancelScrapeBtn = document.getElementById('cancel-scrape');
    const scrapeStatusSpan = document.getElementById('scrape-status');
    const reloadFilesBtn = document.getElementById('reload-files');
    const fuentesPreview = document.getElementById('fuentes-preview-container');
    const toggleConfigBtn = document.getElementById('toggle-config');
    const configPanel = document.getElementById('config-panel');
    const applyConfigBtn = document.getElementById('apply-config');

    let scrapeStatusInterval;

    // --- Configuración del Scraper (valores por defecto) ---
    let scraperConfig = {
        max_depth: 3,
        crawl_strategy: 'continue',
        file_types: ['documents'],
        download_scope: 'same-domain',
        path_restriction: 'base-path',
        save_page_text: true,
        save_html: true
    };

    // --- Toggle Config Panel ---
    toggleConfigBtn.addEventListener('click', () => {
        if (configPanel.style.display === 'none') {
            configPanel.style.display = 'block';
            toggleConfigBtn.textContent = '▲ Ocultar Configuración';
        } else {
            configPanel.style.display = 'none';
            toggleConfigBtn.textContent = '⚙️ Configuración Avanzada';
        }
    });

    // --- Apply Configuration ---
    applyConfigBtn.addEventListener('click', () => {
        // Leer valores del formulario
        scraperConfig.max_depth = parseInt(document.getElementById('max-depth').value);
        scraperConfig.crawl_strategy = document.querySelector('input[name="crawl-strategy"]:checked').value;
        scraperConfig.download_scope = document.querySelector('input[name="download-scope"]:checked').value;
        scraperConfig.path_restriction = document.querySelector('input[name="path-restriction"]:checked').value;
        scraperConfig.save_page_text = document.getElementById('save-page-text').checked;
        scraperConfig.save_html = document.getElementById('save-html').checked;

        // Leer tipos de archivos seleccionados
        const selectedFileTypes = [];
        document.querySelectorAll('input[name="file-type"]:checked').forEach(checkbox => {
            selectedFileTypes.push(checkbox.value);
        });
        scraperConfig.file_types = selectedFileTypes;

        alert('✓ Configuración aplicada correctamente');
        console.log('Configuración actualizada:', scraperConfig);
    });

    // --- Lógica de Pestañas ---
    const tabButtons = document.querySelectorAll('.tab-btn');
    const tabContents = document.querySelectorAll('.tab-content');

    tabButtons.forEach(button => {
        button.addEventListener('click', () => {
            const targetId = button.dataset.tab;
            
            tabButtons.forEach(btn => btn.classList.remove('active'));
            button.classList.add('active');

            tabContents.forEach(content => {
                if (content.id === targetId) {
                    content.classList.add('active');
                } else {
                    content.classList.remove('active');
                }
            });

            // Si la pestaña activa es la de vista previa, renderizar la tabla
            if (targetId === 'fuentes-preview-container') {
                renderCsvAsTable(editors['fuentes.csv'].value);
            }
        });
    });

    const renderCsvAsTable = (csvContent) => {
        const lines = csvContent.trim().split('\n');
        if (lines.length === 0) {
            fuentesPreview.innerHTML = '<p>No hay datos que mostrar.</p>';
            return;
        }

        let table = '<table class="csv-preview-table"><thead><tr>';
        const headers = lines[0].split(';');
        headers.forEach(header => {
            table += `<th>${header}</th>`;
        });
        table += '</tr></thead><tbody>';

        for (let i = 1; i < lines.length; i++) {
            table += '<tr>';
            const cells = lines[i].split(';');
            cells.forEach(cell => {
                // Convertir URLs en enlaces clicables
                if (cell.trim().startsWith('http')) {
                    table += `<td><a href="${cell.trim()}" target="_blank">${cell.trim()}</a></td>`;
                } else {
                    table += `<td>${cell}</td>`;
                }
            });
            table += '</tr>';
        }

        table += '</tbody></table>';
        fuentesPreview.innerHTML = table;
    };

    // --- Lógica de Ficheros ---

    const loadFiles = () => {
        for (const filename in editors) {
            fetch(`/api/files/${filename}`)
                .then(response => response.json())
                .then(data => {
                    if (data.content) {
                        editors[filename].value = data.content;
                        // Si es el editor de fuentes, renderizar la tabla al cargar
                        if (filename === 'fuentes.csv') {
                            renderCsvAsTable(data.content);
                        }
                    }
                })
                .catch(error => console.error(`Error loading ${filename}:`, error));
        }
    };

    // Listener para actualizar la vista previa en tiempo real al escribir
    editors['fuentes.csv'].addEventListener('input', (e) => {
        renderCsvAsTable(e.target.value);
    });

    const saveFile = (filename) => {
        const content = editors[filename].value;
        fetch(`/api/files/${filename}`,
        {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ content }),
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                alert(`${filename} guardado correctamente.`);
            } else {
                alert(`Error al guardar ${filename}: ${data.error}`);
            }
        })
        .catch(error => console.error(`Error saving ${filename}:`, error));
    };

    document.querySelectorAll('.save-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            const filename = btn.dataset.filename;
            if (filename) {
                saveFile(filename);
            }
        });
    });

    reloadFilesBtn.addEventListener('click', () => {
        loadFiles();
        logOutput.textContent = 'Ficheros recargados y vistas limpiadas.';
        procesadosOutput.innerHTML = '<p>Esperando nueva ejecución...</p>';
        alert('Ficheros recargados y vistas limpiadas.');
    });

    // --- Lógica de Scraping y Logs ---

    const updateScrapeStatus = () => {
        fetch('/api/scrape_status')
            .then(response => response.json())
            .then(data => {
                if (data.status === 'running') {
                    startScrapeBtn.disabled = true;
                    startScrapeBtn.textContent = 'Scraping en progreso...';
                    cancelScrapeBtn.style.display = 'inline-block';
                    cancelScrapeBtn.disabled = true;
                    cancelScrapeBtn.textContent = 'Cancelar no soportado';
                    scrapeStatusSpan.textContent = `Scrapeando ${data.current} de ${data.total} fuentes...`;
                } else {
                    startScrapeBtn.disabled = false;
                    startScrapeBtn.textContent = 'Iniciar Scraping';
                    cancelScrapeBtn.style.display = 'none';
                    scrapeStatusSpan.textContent = '';
                    if (scrapeStatusInterval) {
                        clearInterval(scrapeStatusInterval);
                        scrapeStatusInterval = null;
                    }
                }
            })
            .catch(error => {
                console.error('Error fetching scrape status:', error);
                scrapeStatusSpan.textContent = 'Error al obtener estado.';
            });
    };

    startScrapeBtn.addEventListener('click', () => {
        logOutput.textContent = 'Iniciando scraping...'; // Limpiar log anterior
        startScrapeBtn.disabled = true;
        startScrapeBtn.textContent = 'Scraping en progreso...';
        cancelScrapeBtn.style.display = 'inline-block';
        scrapeStatusSpan.textContent = 'Inicializando...';

        // Iniciar polling de estado
        if (!scrapeStatusInterval) {
            scrapeStatusInterval = setInterval(updateScrapeStatus, 1000); // Actualizar cada segundo
        }

        // Enviar la configuración completa al backend
        fetch('/api/scrape', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(scraperConfig)
        })
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    alert(data.error);
                    // Si hay un error al iniciar, restaurar botones
                    startScrapeBtn.disabled = false;
                    startScrapeBtn.textContent = 'Iniciar Scraping';
                    cancelScrapeBtn.style.display = 'none';
                    scrapeStatusSpan.textContent = '';
                    if (scrapeStatusInterval) {
                        clearInterval(scrapeStatusInterval);
                        scrapeStatusInterval = null;
                    }
                } else {
                    alert(data.message);
                }
            })
            .catch(error => {
                console.error('Error starting scrape:', error);
                alert('Error al iniciar el scraping.');
                // En caso de error de red, restaurar botones
                startScrapeBtn.disabled = false;
                startScrapeBtn.textContent = 'Iniciar Scraping';
                cancelScrapeBtn.style.display = 'none';
                scrapeStatusSpan.textContent = '';
                if (scrapeStatusInterval) {
                    clearInterval(scrapeStatusInterval);
                    scrapeStatusInterval = null;
                }
            });
    });

    cancelScrapeBtn.addEventListener('click', () => {
        cancelScrapeBtn.disabled = true;
        cancelScrapeBtn.textContent = 'Cancelando...';
        fetch('/api/scrape/cancel', { method: 'POST' })
            .then(response => response.json())
            .then(data => {
                alert(data.message || data.error);
                cancelScrapeBtn.disabled = false;
                cancelScrapeBtn.textContent = 'Cancelar';
                // El updateScrapeStatus se encargará de restaurar el estado de los botones
            })
            .catch(error => {
                console.error('Error cancelling scrape:', error);
                alert('Error al intentar cancelar el scraping.');
                cancelScrapeBtn.disabled = false;
                cancelScrapeBtn.textContent = 'Cancelar';
            });
    });

    const loadProcesados = () => {
        fetch('/api/procesados')
            .then(response => response.json())
            .then(data => {
                if (data.content) {
                    procesadosOutput.innerHTML = marked.parse(data.content);
                    colorizeResults();
                } else {
                    procesadosOutput.innerHTML = '<p>Aún no hay resultados.</p>';
                }
            })
            .catch(error => console.error('Error loading procesados.md:', error));
    };

    const loadLogs = () => {
        fetch('/api/logs')
            .then(response => response.json())
            .then(data => {
                if (data.content) {
                    let colorizedContent = data.content;

                    // Colorize "--- Starting source:..." in blue
                    colorizedContent = colorizedContent.replace(/(---\sStarting source:.*?---)/g, '<span class="log-blue">$1</span>');

                    // Colorize "[ERROR]" and the error message in red
                    colorizedContent = colorizedContent.replace(/(\[ERROR\])(.*)/g, '<span class="log-red">$1$2</span>');

                    // Colorize "Downloading file", "Saving file", and "Saved page text to" in green
                    colorizedContent = colorizedContent.replace(/(Downloading file.*?\n)/g, '<span class="log-green">$1</span>');
                    colorizedContent = colorizedContent.replace(/(Saving file.*?\n)/g, '<span class="log-green">$1</span>');
                    colorizedContent = colorizedContent.replace(/(Saved page text to.*?\n)/g, '<span class="log-green">$1</span>');


                    logOutput.innerHTML = colorizedContent;
                    logOutput.scrollTop = logOutput.scrollHeight; // Auto-scroll
                }
            })
            .catch(error => console.error('Error loading logs:', error));
    };

    const colorizeResults = () => {
        const rows = procesadosOutput.querySelectorAll('tr');
        rows.forEach((row, index) => {
            if (index === 0) return;
            const cells = row.querySelectorAll('td');
            if (cells.length < 4) return;

            const resultadoText = cells[1].textContent;
            const terminosText = cells[2].textContent;

            row.classList.remove('result-green', 'result-blue', 'result-orange');

            if (terminosText.trim() !== '-') {
                row.classList.add('result-green');
            } else if (resultadoText.includes('Se han descargado')) {
                row.classList.add('result-blue');
            } else {
                row.classList.add('result-orange');
            }
        });
    };

    // --- Carga Inicial y Polling ---
    loadFiles();
    loadProcesados();
    loadLogs();
    updateScrapeStatus(); // Cargar estado inicial

    setInterval(loadProcesados, 5000); 
    setInterval(loadLogs, 3000); // Polling para los logs cada 3 segundos
});
